@{
    var radius = (510-ViewBag.count*10)/ViewBag.count;
    var i = 0;
    var j = 0;
}

@if (Model != null){
    <div style="display: flex; flex-wrap: wrap; gap: 30px;">
        <div style="flex: 1; min-width: 500px;">
            <canvas id="viewCanvas" width="500" height="500" style="border: 1px solid black;"></canvas>
        </div>

        <div style="flex: 1; min-width: 500px;">
            <div style="padding-bottom: 30px; display: flex; gap: 10px;">
                @foreach (var key in @Model.Keys){
                    <button id="option-@j" value="@key" onclick="colorclick(this)" style="border-radius: 50%; height: @(radius + "px"); width: @(radius + "px"); background-color: @ViewBag.colors[key]"></button>
                    j++;
                }
            </div>

            <div>
                @foreach(var key in @ViewBag.sortedKeys){
                    <div id="div-@i" style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button id="correct-@i" value="@key" onclick="colorclick(this, 'answer-@i')" style="width: 245px; height: 30px;">@key</button>
                        <button id="answer-@i" value="null" onclick="colorclick(this)" style="width: 245px; height: 30px; background-color: white;"></button>
                    </div>
                    i++;
                }
                <div style="display: flex; gap: 10px;">
                    <button id="guess" onclick="guess()" style="width:500px; height: 30px;">HÁDAT</button>
                </div>
            </div>
        </div>
    </div>
}

<script>
    function guess(){
        playing=false;
        let score=0;
        for(var i = 0; i < count; i++){
            let div = document.getElementById("div-" + i);
            let answer = document.getElementById("answer-" + i);
            let correct = document.getElementById("correct-" + i);
            answer.style.width = "160px";
            correct.style.width = "160px";
            let solution = document.createElement("button");
            solution.style.width = "160px";
            solution.style.height = "30px";
            solution.style.backgroundColor = colors[correct.value];
            div.appendChild(solution);
            if (answer.value == correct.value) score++;
        }
        let guesslabel = document.getElementById("guess");
        guesslabel.innerText = "SKÓRE: " + score + "/" + count;
        console.log(score);
    }

    function colorclick(button, id=null){
        if (!playing) return;
        if (id != null){
            console.log(id);
            button = document.getElementById(id);
        }
        if (lastclickedbutton == null){
            lastclickedbutton = button;
            previousborderstyle = lastclickedbutton.style.border;
            lastclickedbutton.style.border = "5px solid black";
            console.log(lastclickedbutton);
            return;
        }
        let tmpvalue = button.value;
        let tmpcolor = button.style.backgroundColor;
        console.log(tmpvalue, tmpcolor);

        button.value = lastclickedbutton.value;
        lastclickedbutton.value = tmpvalue;
        button.style.backgroundColor = lastclickedbutton.style.backgroundColor;
        lastclickedbutton.style.backgroundColor = tmpcolor;
        lastclickedbutton.style.border = previousborderstyle;
        lastclickedbutton = null;
    }

    document.addEventListener("DOMContentLoaded", function() {
        drawPoints();
    });
    /**function getRandomColor() {
        const r = Math.floor(Math.random() * 256); // 0–255
        const g = Math.floor(Math.random() * 256);
        const b = Math.floor(Math.random() * 256);
        return `rgb(${r}, ${g}, ${b})`;
    }**/

    var playing=true;
    var previousborderstyle = null;
    var lastclickedbutton = null;
    
    var points = @Html.Raw(Json.Serialize(Model));
    var distance = "@ViewBag.cameradistance";
    var radius = "@ViewBag.sphereradius";
    var center = @Html.Raw(Json.Serialize(ViewBag.center));
    var count = "@ViewBag.count"; 
    var isDragging = false;

    var startX, startY;
    var currQ = {x:0,y:0,z:0,w:1};
    var lastQ = @Html.Raw(Json.Serialize(ViewBag.quaternion));
    const canvas = document.getElementById("viewCanvas");
    const sensitivity = 200;
    var colors = @Html.Raw(Json.Serialize(ViewBag.colors));
    /**let colors = {};
    for (let key in points) {
        colors[key] = {
            r: randomcolors[];
    }**/

    canvas.addEventListener("mousedown", function(event) {
        startX = event.clientX;
        startY = event.clientY;
        isDragging = true;
    });
    canvas.addEventListener("touchstart", function(event) {
        event.preventDefault();
        startX = event.touches[0].clientX;
        startY = event.touches[0].clientY;
        isDragging = true;
    }, {passive: false});
    canvas.addEventListener("mousemove", function(event) {
        if (isDragging){
            let a = project(startX, startY);
            let b = project(event.clientX, event.clientY);
            currQ = quaternionFromVectors(a, b);
            drawPoints();
        }
    });
    canvas.addEventListener("touchmove", function(event) {
        event.preventDefault();
        if (isDragging){
            let a = project(startX, startY);
            let b = project(event.touches[0].clientX, event.touches[0].clientY);
            currQ = quaternionFromVectors(a, b);
            drawPoints();
        }
    }, {passive: false});
    document.addEventListener("mouseup", function(event) {
        lastQ = multiplyQuaternions(currQ, lastQ);
        currQ = {x:0,y:0,z:0,w:1};
        isDragging = false;
    });
    document.addEventListener("touchend", function(event) {
        lastQ = multiplyQuaternions(currQ, lastQ);
        currQ = {x:0,y:0,z:0,w:1};
        isDragging = false;
    });

    function project(x, y){
        const r = 1;
        const res = Math.min(canvas.width, canvas.height) - 1;
        let px = (2 * x - canvas.width - 1) / res;
        let py = (2 * y - canvas.height - 1) / res;
        let d = px*px + py*py;
        if (2*d <= r*r) pz = Math.sqrt(r*r-d);
        else pz = r*r/2/Math.sqrt(d);
        return normalizeVector({
            x:px,
            y:py,
            z:pz
        });
    }

    function quaternionFromVectors(a, b) {
        const axis = cross(a, b);
        const w = 1 + dot(a, b);

        if (w < 1e-6) {
            // Vectors are nearly opposite
            let ortho = {x: 1, y: 0, z: 0};
            if (Math.abs(a.x) > 0.9) ortho = {x: 0, y: 1, z: 0};
            const crossAxis = cross(a, ortho);
            return normalizeQuaternion({
                x: crossAxis.x,
                y: crossAxis.y,
                z: crossAxis.z,
                w: 0
            });
        }

        return normalizeQuaternion({
            x: axis.x,
            y: axis.y,
            z: axis.z,
            w: w
        });
    }

    function dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z;
    }

    function cross(a, b) {
        return {
            x: a.y * b.z - a.z * b.y,
            y: a.z * b.x - a.x * b.z,
            z: a.x * b.y - a.y * b.x
        };
    }

    function drawPoints(){
        let rotatedpoints = [];
        let q = multiplyQuaternions(currQ, lastQ);
        for(let key in points){
            let v = {
                x: (points[key].x - center.x)/radius,
                y: (points[key].y - center.y)/radius,
                z: (points[key].z - center.z)/radius
            };
            var rotatedpoint = rotateVector(q, v);
            rotatedpoints.push({key, rotatedpoint});
        }
        rotatedpoints.sort((a, b) => a.rotatedpoint.z - b.rotatedpoint.z);

        const scale = 200;
        const minRadius = 3;
        const maxRadius = 10;
        ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        for (let point in rotatedpoints){
            const p = rotatedpoints[point].rotatedpoint;
            const distancefromcamera = (distance - p.z*radius)/distance;
            const screenX = canvas.width/2 + (p.x/(distancefromcamera))*scale;
            const screenY = canvas.height/2 + (p.y/(distancefromcamera))*scale;
            const t = (p.z + 1)/2;
            const circleradius = minRadius + t*(maxRadius - minRadius);
            ctx.beginPath();
            ctx.arc(screenX, screenY, circleradius, 0, Math.PI * 2);
            console.log(colors[rotatedpoints[point].key]);
            ctx.fillStyle = colors[rotatedpoints[point].key];
            ctx.fill();
            ctx.lineWidth = 1;
            ctx.strokeStyle = "black";
            ctx.stroke();
        }
    }

    function rotateQuaternion(q, angleX, angleY) {
        let sensitivity = 0.01;
        angleX *= sensitivity;
        angleY *= sensitivity;

        var up = rotateVector(q, {x:0, y:1, z:0});
        var right = rotateVector(q, {x:1, y:0, z:0});

        var qYaw = CreateFromAxisAngle(up, angleX);
        var qPitch = CreateFromAxisAngle(right, angleY);

        var newOrientation = normalizeQuaternion(multiplyQuaternions(qPitch, multiplyQuaternions(qYaw, q)));

        return newOrientation;
    }

    function rotateVector(q, v){
        const qConjugate = {
            x: -q.x,
            y: -q.y,
            z: -q.z,
            w:  q.w
        };

        const vQuat = {
            x: v.x,
            y: v.y,
            z: v.z,
            w: 0
        };

        const temp = multiplyQuaternions(q, vQuat);
        const result = multiplyQuaternions(temp, qConjugate);

        return {
            x: result.x,
            y: result.y,
            z: result.z
        };
    }

    function multiplyQuaternions(a, b){
        return {
            w: a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z,
            x: a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
            y: a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,
            z: a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w
        }
    }

    function normalizeQuaternion(q){
        const length = Math.hypot(q.x, q.y, q.z, q.w);
        return {
            x: q.x / length,
            y: q.y / length,
            z: q.z / length,
            w: q.w / length
        }
    }

    function normalizeVector(v){
        const length = Math.hypot(v.x, v.y, v.z);
        return {
            x: v.x / length,
            y: v.y / length,
            z: v.z / length
        }
    }

    function CreateFromAxisAngle(axis, angle){
        const length = Math.hypot(axis.x, axis.y, axis.z);
        const normalized = {
            x: axis.x / length,
            y: axis.y / length,
            z: axis.z / length
        };
        const halfAngle = angle / 2;
        const sinHalf = Math.sin(halfAngle);
        const cosHalf = Math.cos(halfAngle);
        return {
            x: normalized.x * sinHalf,
            y: normalized.y * sinHalf,
            z: normalized.z * sinHalf,
            w: cosHalf
        };
    }
</script>